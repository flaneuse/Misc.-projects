---
title: "Convert .shp file for Tableau or R"
author: "Laura Hughes"
date: "April 20, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Converting an ESRI Shapefile into a format for Tableau or R
To be able to plot polygons within Tableau or R, you have to convert a shapefile into latitude and longitude coordinates.

Fortunately, there are some nifty packages within R that allow you to do that very easily.  First, you need to import these packages.  Then you'll need to import data, and after that you manipulate your object.

[Useful help document on plotting shapefiles in R using ggplot2](https://github.com/hadley/ggplot2/wiki/plotting-polygon-shapefiles)
[Useful help document on plotting polygons in Tableau](http://kb.tableau.com/articles/knowledgebase/tableau-polygons-arcgis-shapefiles)

### 1. Import necessary R packages. This includes:
* **[dplyr]()**: general functions for manipulating data.  My second favorite package in R.
* **[tidyr]()**: another data wrangling package; needed if you plan to merge any new data to your shapefile (for instance, to use values for a choropleth, which is a map-based heatmap)
* **[rgdal]()**: functions to import and manipulate data
* **[ggplot]()**: contains function to convert shapefiles into lat/lon coordinates. Also an amazingly powerful plotting package for R, and my favourite R package.


### 2. Import your data

```{r importData}
library(rgdal)
library(maptools)
library(rgeos)
library(plyr)
library(ggplot2)

# Set your working directory to the folder that contains your data
setwd('~/Documents/USAID/mini projects/tableaupolygonsfromshapefiles/khm_admbnda_adm1_gov')

# the dsn argument of '.' says to look for the layer in the current directory.
rawAdm1 = rgdal::readOGR(dsn=".", layer="khm_admbnda_adm1_gov")

# pull out the row names from the data and save it as a new column called 'id'
rawAdm1@data$id = rownames(rawAdm1@data)


adm1_points = ggplot2::fortify(rawAdm1, region="id")
adm1_df = plyr::join(adm1_points, rawAdm1@data, by="id")

write.csv(adm1_df, '~/Documents/USAID/mini projects/tableaupolygonsfromshapefiles/khm_admbnda_adm1_gov_tableau.csv')



setwd('~/Documents/USAID/mini projects/tableaupolygonsfromshapefiles/khm_WatrcrsA_wfp/')

# the dsn argument of '.' says to look for the layer in the current directory.
rawLakes = rgdal::readOGR(dsn=".", layer="khm_WatrcrsA_wfp")

# pull out the row names from the data and save it as a new column called 'id'
rawLakes@data$id = rownames(rawLakes@data)


lakes_points = ggplot2::fortify(rawLakes, region="id")
lakes_df = plyr::join(lakes_points, rawLakes@data, by="id")



```

Shapefiles have four components:
* The data
* 

```{r projections}

```


```{r names}

```


```{r appendingData}

```


### Building up a plot in ggplot2
To check that we have what we want, we can plot the file in R using ggplot, quite possibly the most amazing plotting package ever built.  

ggplot is built using the [Grammar of Graphics](http://www.amazon.com/The-Grammar-Graphics-Statistics-Computing/dp/0387245448), where every element of a plot is built up using a series of marks-- basic elements that can be combined to greater effect. So, for example, a bar graph is a series of rectangles that combine to form a bar graph. In the case of a shapefile of polygon data, as you might expect, we'll tell ggplot that we have a group of polygons to plot.

These polygons will be made up of a series of coordinates, with the x being longitude, y being latitude, and will be grouped according to the 'group' variable in our new data frame. The group variable is just a running numbered list of which polygon those coordinates belong to.

In ggplot, those are given to the function by defining the aesthetics within `aes()`. What's great about ggplot is that every component is built up on top of each other, simply by stringing functions together using `+`.  It makes it really powerful to add complexity.  Here, we define where the data is using `ggplot` and `aes`, tell it that we want to plot them as polygons using `geom_polygon` with equal coordinates using `coord_equal`.
```{r plot1}
ggplot(data = adm1_df, mapping = aes(x = long, 
                    y = lat, 
                    group = group)) +
  geom_polygon() +
  coord_equal()
```



To better see the different administrative units, we can color the `fill` by the id for each different polygon:
```{r plot2}
ggplot(adm1_df, aes(x = long, 
                    y = lat, 
                    group = group, 
                    fill = id)) +
  geom_polygon() +
  coord_equal()
```

The aesthetic value `group` is the key to making the coordinates plot in the right order and be connected correctly. If we delet that argument, bad things happen:
```{r plot3}
ggplot(adm1_df, aes(x = long, 
                    y = lat,
                    fill = id)) +
  geom_polygon() +
  coord_equal()
```


You'll also notice that we've set the coordinates to be equal using `coord_equal()`.  If you don't do that, the coordinates will look distorted and screwy:
```{r plot4}
ggplot(adm1_df, aes(x = long, 
                    y = lat, 
                    group = group,
                    fill = id)) +
  geom_polygon()
```


Now that we have a decent plot, we can start to do some fun things and clean it up.  First, we'll get rid of the coordinate background.  ggplot has a bunch of themes that determine the aestethics of how things are plotted: are there grid lines, axes, backgrounds, legends, text, etc. ... and how are they formatted.  There are also preset themes that you can call; here, we'll use `theme_void()`, which is essentially a blank background with a legend. The legend is somewhat meaningless here since we're just coloring the different regions, but would be useful in a traditional choropleth (think heatmap for a map). You can customize all the settings using the `theme` function.
```{r plot5}
ggplot(adm1_df, aes(x = long, 
                    y = lat, 
                    group = group,
                    fill = id)) +
  geom_polygon() +
  coord_equal() +
  theme_void()
```


Next, we can start to add in other layers of complexity. If we have another GIS layer with the lakes and rivers, we can add it on top of the original plot. To do that, we add another `geom_polygon` layer, but we'll need to specify that the underlying data source is different.  ggplot will assume the aesthetics are the same as the main plot unless you say otherwise.

_Note: the lakes layer is complicated so it'll take awhile to plot.
```{r plot6}
ggplot(adm1_df, aes(x = long, 
                    y = lat, 
                    group = group)) +
  geom_polygon(fill = 'grey') +
  coord_equal() +
  theme_void() + 
  geom_polygon(data = lakes_df, fill = 'black') # water should be blue, huh?
```

In ggplot, the items are plotted in the order they appear, so if we switch the lakes layer and the Adm1 layer, we'd hide the lakes.

We can also add a border around the provinces by adding a `geom_line` layer